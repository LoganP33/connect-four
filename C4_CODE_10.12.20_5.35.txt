import numpy as np 
from random import randrange
import time

ROW_COUNT = 6
COLUMN_COUNT = 7

def create_board():
  board = np.zeros((6, 7))
  return board

def create_history():                   #Creates an array history which will stored the column # of each move which can be used to recreate each move of the board at the end.
    history = np.full(42,9)
    return history

def show_game_history(history_array, gamepiece1, gamepiece2):
    last_game_board = create_board()
    i = 1
    while(i <= 42 and history_array[i] != 9):
        col = history_array[i]
        if(is_valid_location(last_game_board, col)):
            row = get_next_open_row(history_array, col) #Row is assigned based on the next available row in the column
            drop_gamepiece(history_array, row, col, gamepiece)
    

def drop_gamepiece(board, row, col, gamepiece): #places the gamepiece
    board[row][col] = gamepiece

def is_valid_location(board, col): #checks if the selected colomn is full
  if(board[0][col] == 0):
    return True

def print_gameboard(board):
    print("  0  1  2  3  4  5  6")
    print("  |  |  |  |  |  |  |")
    print(board)

def get_next_open_row(board, col): #checks which slot the player token will fill
    r = 0
    while(r in range(ROW_COUNT-1) and board[r][col] == 0): #looks at array from top down
        if(r <= 4 and board[r+1][col] != 0):
            break
        r+=1
    return r  #returns first row = 0

def winning_move(board, r, c, gamepiece):
  #check horizontal locations for win 
   #check below [-][]
    if(r <= 2):
        if (board[r+1][c] == gamepiece and board[r+2][c] == gamepiece and board[r+3][c] == gamepiece):
            return True
    #check left and right [][-] and [][+]
    if (c <= 3):                                                                                            #Checks for: O-X-X-X
        if (board[r][c+1] == gamepiece and board[r][c+2] == gamepiece and board[r][c+3] == gamepiece):
            return True
    if(c >= 2 and c != 6):                                                                                  #Checks for: X-X-O-X
        if (board[r][c-1] == gamepiece and board[r][c-2] == gamepiece and board[r][c+1] == gamepiece):
            return True
    if(c >= 1 and c <= 4):                                                                                  #Checks for: X-O-X-X
        if (board[r][c-1] == gamepiece and board[r][c+1] == gamepiece and board[r][c+2] == gamepiece):
            return True
    if(c >= 3):                                                                                             #Checks for: X-X-X-O
        if (board[r][c-1] == gamepiece and board[r][c-2] == gamepiece and board[r][c-3] == gamepiece):
            return True

    #check upper/lower right/left diagonal    [-][+] and [-][-]
    if(r >= 3 and c <= 3):                                                                                      #Checks for: O/X/X/X
        if (board[r-1][c+1] == gamepiece and board[r-2][c+2] == gamepiece and board[r-3][c+3] == gamepiece):
            return True
    if(r >= 2 and r<= 4 and c <= 4 and c >= 1):                                                                 #Checks for: X/O/X/X
        if (board[r-1][c+1] == gamepiece and board[r-2][c+2] == gamepiece and board[r+1][c-1] == gamepiece):
            return True
    if(r >= 1 and r <= 3 and c <= 5 and c >= 2 ):                                                               #Checks for: X/X/O/X
        if (board[r-1][c+1] == gamepiece and board[r+1][c-1] == gamepiece and board[r+2][c-2] == gamepiece):
            return True
    if(r <= 2 and c >= 3):                                                                                      #Checks for: X/X/X/O
        if (board[r+1][c-1] == gamepiece and board[r+2][c-2] == gamepiece and board[r+3][c-3] == gamepiece):
            return True
    if(r <= 2 and c <= 3):                                                                                      #Checks for: O\X\X\X
        if (board[r+1][c+1] == gamepiece and board[r+2][c+2] == gamepiece and board[r+3][c+3] == gamepiece):
            return True
    if(r <= 3 and r >= 1 and c <= 4 and c >= 1):                                                                #Checks for: X\O\X\X
        if (board[r+1][c+1] == gamepiece and board[r+2][c+2] == gamepiece and board[r-1][c-1] == gamepiece):
            return True
    if(r <= 4 and r >= 2 and c >= 2 and c <= 5):                                                                #Checks for: X\X\O\X
        if (board[r+1][c+1] == gamepiece and board[r-1][c-1] == gamepiece and board[r-2][c-2] == gamepiece):
            return True
    if(r >= 3 and c >= 3):                                                                                      #Checks for: X\X\X\O
        if (board[r-1][c-1] == gamepiece and board[r-2][c-2] == gamepiece and board[r-3][c-3] == gamepiece):
            return True

def player_move(gamepiece, playerID):
    print("========================================Player " + playerID + "'s(" + str(gamepiece) + ")" + " turn========================================\n")
    print_gameboard(board)
    col = int(input ("Player " + playerID + "(" + str(gamepiece) + ")" + " Make your Selection (0-6):"))
    print("")

    i = 0
    while(i != 2):                              #Until you get a valid location, continue this loop
        if(is_valid_location(board, col)):
            row = get_next_open_row(board, col) #Row is assigned based on the next available row in the column
            drop_gamepiece(board, row, col, gamepiece)
            i = 2
        else:
            print("\n======================Invalid move. Please select a column with an open space======================")
            print(board)
            col = int(input ("Player " + playerID + "(" + str(gamepiece) + ")" + " Make your Selection (0-6):"))
      
    if winning_move(board, row, col, gamepiece) == True:
        print("================================================================================================")
        print("========================================THE GAME IS OVER========================================")
        print("================================================================================================\n")
        print(board)
        print("Player " + playerID + "(" + str(gamepiece) + ")" + " Wins!")
        global game_over
        game_over = 2

def computer_move(gamepiece, computerID, computerMode):
    print(" [0  1  2  3  4  5  6]\n")
    print(board)
    print(computerID + "(" + str(gamepiece) + ")" + " Is making a selection", end = '')
    time.sleep(1)
    print(".", end = '')
    time.sleep(1)
    print(".", end = '')
    time.sleep(1)
    print(".\n\n", end = '')
    col = randrange(6)

    i = 0
    while(i != 2):                              #Until you get a valid location, continue this loop
        if(is_valid_location(board, col)):
            row = get_next_open_row(board, col) #Row is assigned based on the next available row in the column
            drop_gamepiece(board, row, col, gamepiece)
            i = 2
        else:
            col = randrange(6)      
    
    if winning_move(board, row, col, gamepiece) == True:
        print(board)
        print(+ playerID + " wins!")
        global game_over
        game_over = 2   
    print("\n")


def player_vs_player():
    global game_over
    game_over = 1
    player1ID = input("Enter a name for player 1: ")
    player2ID = input("Enter a name for player 2: ")
    print("")

    while(game_over != 2):
        player_move(1, player1ID)
        if(game_over == 2):                 #Need better idea than global variable...
            break
        player_move(2, player2ID)


def player_vs_computer():
    global game_over
    game_over = 1
    player1ID = input("Enter a name for player 1: ")
    computer1ID = "Computer"
    computer_mode = 1               #Computer is easy mode (random moves)

    while(game_over != 2):
        player_move(1, player1ID)
        if(game_over == 2):
            break
        computer_move(2, computer1ID, computer_mode)

########### Main ###########
end = 0                                    #Variable used to exit program
while(end != 2):
    print("Connect Four Main Menu\n1.) Player Vs. Player\n2.) Player Vs. Computer\n3.) Computer Vs. Computer\n4.) Exit")
    mainmenu_option = int(input())

    if(mainmenu_option == 1):
        board = create_board()
        player_vs_player()
        print("\nSelect an Option\n1.) Rematch\n2.) Show Game History\n3.) Return to Main Menu\n4.) Exit")
        endgame_option = int(input())
        if(endgame_option == 1):
            board = create_board()
            player_vs_player()
        elif(endgame_option == 2):
            
        elif(endgame_option == 3):
            mainmenu_option = 0

    
    if(mainmenu_option == 2):
        board = create_board()
        player_vs_computer()




        while(game_over != 2):
            player_move(1, player1ID)
            if(game_over == 2):
                break
            computer_move(2, computer1ID, computer_mode)
        print("======================================================================\n")
        print(board)

    if(mainmenu_option == 4):
        print("Program exiting...")
        end = 2

    print("")